#pragma once

//#include <vector>
#include <direct.h>
#include <iomanip>
#include "staff.h"
#include "DuplicateGroup.h"

using namespace System;//TODO remove this line and all log prints before publishing this tool

public class DuplicatesFinder
{

public:

	/*parses the CSV stringstream and any associated pause file data, prepares the data for finding duplicates, and returns the number of staff found*/
	int parse(std::stringstream& wholeCsv) {
		Console::WriteLine("parse");

		//parses the whole csv stringstream		
		size_t vectorHash = 0;
		int staffCount = -1;
		while (!wholeCsv.eof()) {
			if (staffCount >= 0) {
				//adds staff to vector
				Staff s = getStaffFromLine(wholeCsv, staffCount);
				if (s.id >= 0) {
					staffVector.push_back(s);

					//calculates the hash of the vector, for use in the pause/resume feature
					vectorHash = Staff::combineHash(vectorHash, s.getHash());

					/*if (staffCount % 1000 == 0) {
						Console::WriteLine("Progress: staff count: {0}; Hash so far: {1}", staffCount, vectorHash);
					}*/
				}
				else {
					//s.id < 0 means it read an empty line, so we ignore and reduce staffCount
					staffCount--;
				}				
			}
			else {
				//skips header
				getStaffFromLine(wholeCsv, staffCount);
			}
			staffCount++;
		}		
		if (staffCount < 0) {
			staffCount = 0;
		}
		Console::WriteLine("Parsed {0} staff. Final vector hash {1}", staffCount, vectorHash);						

		//Initializes the duplicates vector. We use one vector of duplicate groups for each duplicate type.
		duplicates.reserve(DuplicateGroup::NUMBER_OF_DUPLICATE_TYPES);
		for (int i = 0; i < DuplicateGroup::NUMBER_OF_DUPLICATE_TYPES; ++i)
		{
			std::vector<DuplicateGroup> emptyVector;
			duplicates.push_back(emptyVector);
		}

		//checks if a valid pause file for this csv file already exists. If yes, parses it and fills the duplicate vectors so it resumes
		//from where it last paused.
		int lastStaffId = -1;
		staffVectorHash = std::to_string(staffCount) + std::to_string(vectorHash);			
		std::ifstream pauseFile(getPausePath(staffVectorHash), std::ios::binary);
		if (pauseFile) {
			Console::WriteLine("Pause File opened");

			//reads the whole pause file at once into an stringstream				
			std::stringstream* wholePauseFile = new std::stringstream();
			*wholePauseFile << pauseFile.rdbuf();
			Console::WriteLine("Pause File read");		

			pauseFile.close();
			Console::WriteLine("Pause File closed");

			int currentDupType = 0;
			int currentGroupId = 0;				
			while (!wholePauseFile->eof()) {				
				std::vector<std::string> lineStrings = getPauseInfoFromLine(*wholePauseFile);				
				if (lineStrings.size() > 1) {					
					if (lineStrings.at(0).compare(STAFF_IDS_S) == 0) {						
						DuplicateGroup currentDupGroup(currentGroupId, currentDupType);												
						for (size_t i = 1; i < lineStrings.size(); i++) {
							int currentStaffId = std::stoi(lineStrings.at(i));
							currentDupGroup.addStaffId(currentStaffId);
							staffVector.at(currentStaffId).duplicateGroupId[currentDupType] = currentGroupId;							
						}												
						duplicates.at(currentDupType).push_back(currentDupGroup);
					}
					else if (lineStrings.at(0).compare(GROUP_ID_S) == 0) {
						currentGroupId = std::stoi(lineStrings.at(1));
					}					
					else if (lineStrings.at(0).compare(DUP_TYPE_S) == 0) {
						currentDupType = std::stoi(lineStrings.at(1));
					}
					else if (lineStrings.at(0).compare(CURRENT_STAFF_ID_S) == 0) {
						lastStaffId = std::stoi(lineStrings.at(1));
					}
					else if (lineStrings.at(0).compare(TOOL_VERSION_S) == 0) {						
						if (lineStrings.at(1).compare(TOOL_VERSION) != 0) {							
							//the pause file was generated by a different tool version than current tool,
							//so we break out of the while loop and let the algorithm start processing from the beginning
							break;
						}
					}					
				}
			}	
			Console::WriteLine("PauseFile parsed. lastStaffId == {0}", lastStaffId);
			
			delete wholePauseFile;
			wholePauseFile = NULL;
		}
		else {
			Console::WriteLine("Couldnt open the pause file");
		}

		//initializes the main iterator		
		i = staffVector.begin() + (lastStaffId + 1);
		
		return staffCount;
	}	

	/*finds some duplicates and returns the current list of duplicates as an string*/
	std::string findDuplicates() {		
		Console::WriteLine("findDuplicates");

		if (firstIteration) {
			//returs an empty printable list in the first iteration (or returns the current progress if resuming from paused state)
			//so that the user can have an initial visual feedback
			firstIteration = false;
			if (staffVector.size() <= 0) {
				//the csv file is empty, so we pass -1 as the currentStaffId
				return printableDuplicatesList(-1);				
			}
			else {
				return printableDuplicatesList(i->id);
			}
		}

		writeProgressIntoFile();
		
		//finds the duplicates
		int iterMax = i->id + MAX_ITERATIONS_WITHOUT_REPORTING;
		Console::WriteLine("currentStaffIterator: {0}, iterMax {1}", i->id, iterMax);
		for (bool foundDuplicate = false; i < staffVector.end() && i->id < iterMax && !foundDuplicate; ++i) {
			Console::WriteLine("Progress: staff i: {0}", i->id);
			if (i->id == iterMax - 1) {
				Console::WriteLine("Iter max reached. Progress: staff i: {0}", i->id);
			/*	duplicatesList = printDuplicatesList(duplicates, staffVector, i->id);
				String ^systemstring3 = gcnew String(duplicatesList.c_str());
				Console::WriteLine("{0}", systemstring3);
				delete systemstring3;*/
			}
			for (std::vector<Staff>::iterator j = i+1; j < staffVector.end(); ++j) {
				int duplicateType = Staff::Compare(*i, *j);

				if (duplicateType >= 0 && duplicateType < DuplicateGroup::NUMBER_OF_DUPLICATE_TYPES) {
					//then staff i is possible duplicate with staff j
					
					//sets this bool to true so that we save the updated duplicates list into the output file and
					//return to c# to update the visible list to the user
					foundDuplicate = true;

					/*Console::WriteLine("possible duplicate: {0}", duplicateType);
					String ^systemstring = gcnew String(i->print().c_str());
					Console::WriteLine("{0}", systemstring);
					delete systemstring;
					String ^systemstring2 = gcnew String(j->print().c_str());
					Console::WriteLine("{0}", systemstring2);
					delete systemstring2;*/

					if (i->duplicateGroupId[duplicateType] < 0 && j->duplicateGroupId[duplicateType] < 0) {
						//Console::WriteLine("none of them are in duplicate groups for this duplicate type");
						//none of them are in duplicate groups for this duplicate type, so we add them in a new duplicate group for this type
						int groupId = duplicates.at(duplicateType).size();
						DuplicateGroup dg = DuplicateGroup(groupId, duplicateType);
						dg.addStaffId(i->id);
						dg.addStaffId(j->id);
						duplicates.at(duplicateType).push_back(dg);
						i->duplicateGroupId[duplicateType] = groupId;
						j->duplicateGroupId[duplicateType] = groupId;
					}
					else if (i->duplicateGroupId[duplicateType] >= 0 && j->duplicateGroupId[duplicateType] >= 0) {						
						if (i->duplicateGroupId[duplicateType] != j->duplicateGroupId[duplicateType]) {
							//Console::WriteLine("both are in different duplicate groups for this duplicate type, so we merge their groups");
							//both are in different duplicate groups for this duplicate type, so we merge their groups
							duplicates.at(duplicateType).at(j->duplicateGroupId[duplicateType]).duplicateType = DuplicateGroup::DUPLICATE_TYPE_MERGED;
							std::vector<int> jStaffIds;
							for (std::unordered_set<int>::iterator it = duplicates.at(duplicateType).at(j->duplicateGroupId[duplicateType]).staffIds.begin();
								it != duplicates.at(duplicateType).at(j->duplicateGroupId[duplicateType]).staffIds.end(); ++it)
							{								
								jStaffIds.push_back(*it);
							}
							for (std::vector<int>::iterator it = jStaffIds.begin(); it != jStaffIds.end(); ++it) {							
								duplicates.at(duplicateType).at(i->duplicateGroupId[duplicateType]).addStaffId(*it);
								staffVector.at(*it).duplicateGroupId[duplicateType] = i->duplicateGroupId[duplicateType];
							}
						}
						else {
							//Console::WriteLine("both are in the same duplicate group for this duplicate type already, so we do nothing");
							//both are in the same duplicate group for this duplicate type already, so we do nothing
						}
					}
					else if (i->duplicateGroupId[duplicateType] >= 0) {
						//Console::WriteLine("only the staff 'i' is in a duplicate group for this duplicate type, so we add staff 'j' to the same group");
						//only the staff 'i' is in a duplicate group for this duplicate type, so we add staff 'j' to the same group
						duplicates.at(duplicateType).at(i->duplicateGroupId[duplicateType]).addStaffId(j->id);
						j->duplicateGroupId[duplicateType] = i->duplicateGroupId[duplicateType];
					}
					else {
						//Console::WriteLine("only the staff 'j' is in a duplicate group for this duplicate type, so we add staff 'i' to the same group");
						//only the staff 'j' is in a duplicate group for this duplicate type, so we add staff 'i' to the same group
						duplicates.at(duplicateType).at(j->duplicateGroupId[duplicateType]).addStaffId(i->id);
						i->duplicateGroupId[duplicateType] = j->duplicateGroupId[duplicateType];
					}

					/*duplicatesList = printDuplicatesList(duplicates, staffVector, i->id);					
					String ^systemstring3 = gcnew String(duplicatesList.c_str());
					Console::WriteLine("{0}", systemstring3);
					delete systemstring3;*/
				}				 
			}
		}		
		
		//currentStaffId is set to be the ID of the staff we last checked in the loop
		int currentStaffId;
		if (i < staffVector.end()) {
			//the processing isnt completed yet, so the iterator is pointing to the next staff, so we subtract 1 to get the current staff id
			currentStaffId = i->id - 1;
		} else {
			//the processing is completed, because all staff vector has been checked
			//so we set the current staff id as the id of the final staff in the vector
			currentStaffId = staffVector.back().id;			
		}		
		return printableDuplicatesList(currentStaffId);
	}

	/*saves the formated result duplicates list into a txt file, and pause / resume information into a pause file.*/
	void writeProgressIntoFile() {
		//writes the current result into a file for the user
		std::ofstream resultFile(RESULT_FILENAME, std::ios::binary | std::ios::trunc);
		if (resultFile) {
			//resultFile << result;
			resultFile.write(result.c_str(), sizeof(char)*result.size());
			/*if (!resultFile) {
				//TODO: print some message to user if write fail as it probably means the user instaled the app in some admin protected folder
				Console::WriteLine("duplicates result file write failed");
			}*/
			resultFile.close();
		}
		else {
			//TODO: print some message to user if write fail as it probably means the user instaled the app in some admin protected folder
		}

		//creates the pause data directory if it doesn't exist
		_mkdir(PAUSE_DIR);
		//writes the current pause data into a file for the pause resume feature		
		std::ofstream pauseFile(getPausePath(staffVectorHash), std::ios::binary | std::ios::trunc);
		if (pauseFile) {
			//pauseFile << pauseData;
			pauseFile.write(pauseData.c_str(), sizeof(char)*pauseData.size());
			/*if (!pauseFile) {
				//TODO: print some message to user if write fail as it probably means the user instaled the app in some admin protected folder
				Console::WriteLine("pause file write failed");
			}*/
			pauseFile.close();
		}
		else {
			//TODO: print some message to user if write fail as it probably means the user instaled the app in some admin protected folder
		}
	}


private:
	//hardcoded values as per the csv generated by the TransferTool app
	static constexpr int firstNameIndex = 0;
	static constexpr int lastNameIndex = 1;
	static constexpr int commonNameIndex = 2;
	static constexpr int dobIndex = 3;
	static constexpr int clubIndex = 9;	
	static constexpr int loanIndex = 10;

	//When more than this number of iterations is reached without finding any new duplicates,
	//we return to c# layer to update the progress bar
	static constexpr int MAX_ITERATIONS_WITHOUT_REPORTING = 250;	
	
	//If change this RESULT_FILENAME constant here, then the UI in c# side needs to be manually changed as well to reflect the new filename
	//TODO: let the user choose the name for this result file
	static constexpr char * RESULT_FILENAME = "DuplicatesList.txt";
	static constexpr char * PAUSE_DIR = "PAUSE_DATA";
	static constexpr char * PAUSE_FILENAME = "PAUSE_";
	static constexpr char * PAUSE_HEADER = "This file is autogenerated by the CMDuplicatesFinder tool and only used internally by the tool, for the pause and resume feature. Manually editting this file may cause the pause and resume feature to fail or the tool to crash. If you think this file is corrupted and causing a crash or failure in the tool, you can delete this file and the tool will recreate it properly.\r\n";
	
	//whenever releasing a new version of this tool, this TOOL_VERSION constant needs to be updated too, otherwise pause resume feature may fail
	//TODO: make this TOOL_VERSION constant to update automatically on new release by passing some version string from C# to this layer
	static constexpr char * TOOL_VERSION = "v0.4-beta";
	static constexpr char * TOOL_VERSION_S = "ToolVersion";
	static constexpr char * CURRENT_STAFF_ID_S = "CurrentStaffId";
	static constexpr char * DUP_TYPE_S = "DupType";
	static constexpr char * GROUP_ID_S = "G";
	static constexpr char * STAFF_IDS_S = "S";
	
	std::string staffVectorHash;
	std::string pauseData;
	std::string result;
	std::vector<Staff> staffVector;
	std::vector<std::vector<DuplicateGroup>> duplicates;
	std::vector<Staff>::iterator i;
	bool firstIteration = true;		

	/*returns an string with the duplicates list formated to be displayed to user, and some header for internal use by the app;
	Also, prepares pause/resume information to be saved into a pause file.
	Note: if the staffVector is empty, pass -1 as currentStaffId*/
	std::string printableDuplicatesList(int currentStaffId) {
		//TODO: sort result by likelly chances with a percentage score based on their similarity substitutions?
		bool isCompleted = false;
		float progress = 100.0;
		std::string internalUse;		
		
		//prepares the strings for the pause data
		std::string ph(PAUSE_HEADER);
		std::string tvs(TOOL_VERSION_S);
		std::string tv(TOOL_VERSION);
		std::string dt(DUP_TYPE_S);
		std::string gi(GROUP_ID_S);
		std::string si(STAFF_IDS_S);
		std::string csi(CURRENT_STAFF_ID_S);
		pauseData = ph + tvs + ";" + tv + ";;\r\n";
		pauseData += csi + ";" + std::to_string(currentStaffId) + ";;\r\n";

		/*the first two lines of the result string are for internal use by the code, it isn't print to the user, its just
		to pass progress information between c++ and c# layer*/
		if (staffVector.size() == currentStaffId + 1) {			
			isCompleted = true;
			internalUse += "1";
		}
		else {
			internalUse += "0";
		}
		internalUse += "\n" + std::to_string(currentStaffId) + "\n";
		//printUnmanagedString(internalUse);

		result = "DUPLICATES LIST - ";
		if (isCompleted) {
			result += "FULL ";
		}
		else {
			result += "PARTIAL ";
			progress = ((float)currentStaffId / (float)staffVector.size()) * 100.0f;			
		}
		result += "RESULT (";
		if (!isCompleted) {
			std::stringstream floatStream;
			floatStream << std::fixed << std::setprecision(2) << progress;			
			result += "PROGRESS COMPLETED SO FAR: " + floatStream.str() + "% : ";
		}
		int duplicatesFound = 0;
		for (int i = 0; i < DuplicateGroup::NUMBER_OF_DUPLICATE_TYPES; ++i)
		{
			std::vector<DuplicateGroup> groupVector = duplicates.at(i);
			duplicatesFound += groupVector.size();
		}
		result += std::to_string(duplicatesFound) + " DUPLICATE GROUPS FOUND";
		if (!isCompleted) {
			result += " SO FAR";
		}
		result += "):\r\n";
		result += "Legend: (FN = First name; LN = Last name; CN = Common name; DOB = Date of birth)\r\n";
		 
		for (int i = 0; i < DuplicateGroup::NUMBER_OF_DUPLICATE_TYPES; ++i)
		{
			pauseData += dt + ";" + std::to_string(i) + ";;\r\n";
			result += "\r\n\r\n************************* DUPLICATE TYPE " + DuplicateGroup::getTypeTitle(i) + " (";
			std::vector<DuplicateGroup> groupVector = duplicates.at(i);
			result += std::to_string(groupVector.size()) + " DUPLICATE GROUPS FOUND";
			if (!isCompleted) {
				result += " SO FAR";
			}
			result += "):\r\n";
			for (std::vector<DuplicateGroup>::iterator j = groupVector.begin(); j != groupVector.end(); ++j) {
				if (j->duplicateType >= 0) {
					pauseData += gi + ";" + std::to_string(j->groupId) + ";;\r\n" + si;
					result += "    DUPLICATE GROUP ID " + DuplicateGroup::getGroupIdTitle(i) + std::to_string(j->groupId) + ":\r\n";
					for (std::unordered_set<int>::iterator k = j->staffIds.begin(); k != j->staffIds.end(); ++k) {
						pauseData += ";" + std::to_string(*k);
						result += "        " + staffVector.at(*k).print() + "\r\n";
					}
					pauseData += ";;\r\n";
				}
			}			
		}		

		return internalUse + result;
	}

	/*parses one line of the csv file and returns the corresponding Staff*/
	static Staff getStaffFromLine(std::stringstream& wholeCsv, int staffCount)
	{		
		std::string line;		
		std::getline(wholeCsv, line);

		if (staffCount < 0 || line.empty()) {
			//ignores header and any empty lines
			Staff staff;
			return staff;
		}

		std::string fn, ln, cn, dob, club, loan;
		
		std::istringstream lineStream(line);				
		
		int index = 0;
		std::string cell;
		while (std::getline(lineStream, cell, ';') && index <= loanIndex)
		{
			if (index == firstNameIndex) {
				fn = cell;
			}
			else if (index == lastNameIndex) {
				ln = cell;
			}
			else if (index == commonNameIndex) {
				cn = cell;
			}
			else if (index == dobIndex) {
				dob = cell;
			}
			else if (index == clubIndex) {
				club = cell;
			}		
			else if (index == loanIndex) {
				loan = cell;
			}
			index++;
		}
		/*// checks for a trailing comma with no data after it
		if (!lineStream && cell.empty())
		{
			// if there was a trailing comma then adds an empty element
			staff.push_back("");
		}*/		
		return Staff(staffCount, fn, ln, cn, dob, club, loan);
	}

	/*parses one line from the pause file and returns the strings that were separated by the ;*/
	static std::vector<std::string> getPauseInfoFromLine(std::stringstream& wholePauseFile)
	{
		std::string line;
		std::getline(wholePauseFile, line);

		std::vector<std::string> ret;

		if (line.empty()) {
			//ignores empty lines
			return ret;
		}		

		std::istringstream lineStream(line);

		std::string cell;
		while (std::getline(lineStream, cell, ';'))
		{
			if (cell.empty()) {
				//then we reached the ';;' which is our end of line marker
				break;
			}
			ret.push_back(cell);		
		}			
		/*// checks for a trailing comma with no data after it
		if (!lineStream && cell.empty())
		{
			// if there was a trailing comma then adds an empty element
			staff.push_back("");
		}*/
		return ret;
	}

	//returns the full path to the current pause file being used
	static std::string getPausePath(std::string pauseHash) {
		std::string pausePath(PAUSE_DIR);
		std::string pauseFilename(PAUSE_FILENAME);
		return pausePath + "\\" + pauseFilename + pauseHash;
	}

	/*prints the unmanaged string in managed code*/
	static void printUnmanagedString(std::string s) {
		String ^systemstring = gcnew String(s.c_str());
		Console::WriteLine("{0}", systemstring);
		delete systemstring;
	}
};
